<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Persistent_volume_spec (rekube.Rekube.Kubernetes.Definitions.Api.Core.V1.Persistent_volume_spec)</title><link rel="stylesheet" href="../../../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../../../../index.html">rekube</a> &#x00BB; <a href="../../../../../../index.html">Rekube</a> &#x00BB; <a href="../../../../../index.html">Kubernetes</a> &#x00BB; <a href="../../../../index.html">Definitions</a> &#x00BB; <a href="../../../index.html">Api</a> &#x00BB; <a href="../../index.html">Core</a> &#x00BB; <a href="../index.html">V1</a> &#x00BB; Persistent_volume_spec</nav><h1>Module <code>V1.Persistent_volume_spec</code></h1><p>Persistent_volume_spec is the specification of a persistent volume.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code>;</dt></dl><dl><dt class="spec value" id="val-to_yojson"><a href="#val-to_yojson" class="anchor"></a><code><span class="keyword">let</span> to_yojson: <a href="index.html#type-t">t</a> <span>=&gt;</span> Yojson.Safe.json;</code></dt><dt class="spec value" id="val-of_yojson"><a href="#val-of_yojson" class="anchor"></a><code><span class="keyword">let</span> of_yojson: Yojson.Safe.json <span>=&gt;</span> Ppx_deriving_yojson_runtime.error_or(<a href="index.html#type-t">t</a>);</code></dt><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: ?&#8288;vsphere_volume:<a href="../Vsphere_virtual_disk_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Vsphere_virtual_disk_volume_source.t</a> <span>=&gt;</span> ?&#8288;volume_mode:string <span>=&gt;</span> ?&#8288;storageos:<a href="../Storage_os_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Storage_os_persistent_volume_source.t</a> <span>=&gt;</span> ?&#8288;storage_class_name:string <span>=&gt;</span> ?&#8288;scale_io:<a href="../Scale_io_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Scale_io_persistent_volume_source.t</a> <span>=&gt;</span> ?&#8288;rbd:<a href="../Rbd_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Rbd_persistent_volume_source.t</a> <span>=&gt;</span> ?&#8288;quobyte:<a href="../Quobyte_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Quobyte_volume_source.t</a> <span>=&gt;</span> ?&#8288;portworx_volume:<a href="../Portworx_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Portworx_volume_source.t</a> <span>=&gt;</span> ?&#8288;photon_persistent_disk:<a href="../Photon_persistent_disk_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Photon_persistent_disk_volume_source.t</a> <span>=&gt;</span> ?&#8288;persistent_volume_reclaim_policy:string <span>=&gt;</span> ?&#8288;node_affinity:<a href="../Volume_node_affinity/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Volume_node_affinity.t</a> <span>=&gt;</span> ?&#8288;nfs:<a href="../Nfs_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Nfs_volume_source.t</a> <span>=&gt;</span> ?&#8288;mount_options:list(string) <span>=&gt;</span> ?&#8288;local:<a href="../Local_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Local_volume_source.t</a> <span>=&gt;</span> ?&#8288;iscsi:<a href="../Iscsi_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Iscsi_persistent_volume_source.t</a> <span>=&gt;</span> ?&#8288;host_path:<a href="../Host_path_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Host_path_volume_source.t</a> <span>=&gt;</span> ?&#8288;glusterfs:<a href="../Glusterfs_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Glusterfs_volume_source.t</a> <span>=&gt;</span> ?&#8288;gce_persistent_disk:<a href="../Gce_persistent_disk_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Gce_persistent_disk_volume_source.t</a> <span>=&gt;</span> ?&#8288;flocker:<a href="../Flocker_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Flocker_volume_source.t</a> <span>=&gt;</span> ?&#8288;flex_volume:<a href="../Flex_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Flex_persistent_volume_source.t</a> <span>=&gt;</span> ?&#8288;fc:<a href="../Fc_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Fc_volume_source.t</a> <span>=&gt;</span> ?&#8288;csi:<a href="../Csi_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Csi_persistent_volume_source.t</a> <span>=&gt;</span> ?&#8288;claim_ref:<a href="../Object_reference/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Object_reference.t</a> <span>=&gt;</span> ?&#8288;cinder:<a href="../Cinder_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Cinder_volume_source.t</a> <span>=&gt;</span> ?&#8288;cephfs:<a href="../Ceph_fs_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Ceph_fs_persistent_volume_source.t</a> <span>=&gt;</span> ?&#8288;capacity:<a href="../../../../Apimachinery/Pkg/Api/Resource/Quantity/Object/index.html#type-t">Kubernetes.Definitions.Apimachinery.Pkg.Api.Resource.Quantity.Object.t</a> <span>=&gt;</span> ?&#8288;azure_file:<a href="../Azure_file_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Azure_file_persistent_volume_source.t</a> <span>=&gt;</span> ?&#8288;azure_disk:<a href="../Azure_disk_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Azure_disk_volume_source.t</a> <span>=&gt;</span> ?&#8288;aws_elastic_block_store:<a href="../Aws_elastic_block_store_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Aws_elastic_block_store_volume_source.t</a> <span>=&gt;</span> ?&#8288;access_modes:list(string) <span>=&gt;</span> unit <span>=&gt;</span> <a href="index.html#type-t">t</a>;</code></dt><dt class="spec value" id="val-type_info"><a href="#val-type_info" class="anchor"></a><code><span class="keyword">let</span> type_info: unit <span>=&gt;</span> Depyt.t(<a href="index.html#type-t">t</a>);</code></dt><dt class="spec value" id="val-access_modes"><a href="#val-access_modes" class="anchor"></a><code><span class="keyword">let</span> access_modes: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(list(string));</code></dt><dd><p>Access_modes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes</p></dd></dl><dl><dt class="spec value" id="val-aws_elastic_block_store"><a href="#val-aws_elastic_block_store" class="anchor"></a><code><span class="keyword">let</span> aws_elastic_block_store: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Aws_elastic_block_store_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Aws_elastic_block_store_volume_source.t</a>);</code></dt><dd><p>Aws_elastic_block_store represents an Aws Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore</p></dd></dl><dl><dt class="spec value" id="val-azure_disk"><a href="#val-azure_disk" class="anchor"></a><code><span class="keyword">let</span> azure_disk: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Azure_disk_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Azure_disk_volume_source.t</a>);</code></dt><dd><p>Azure_disk represents an Azure Data Disk mount on the host and bind mount to the pod.</p></dd></dl><dl><dt class="spec value" id="val-azure_file"><a href="#val-azure_file" class="anchor"></a><code><span class="keyword">let</span> azure_file: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Azure_file_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Azure_file_persistent_volume_source.t</a>);</code></dt><dd><p>Azure_file represents an Azure File Service mount on the host and bind mount to the pod.</p></dd></dl><dl><dt class="spec value" id="val-capacity"><a href="#val-capacity" class="anchor"></a><code><span class="keyword">let</span> capacity: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../../../../Apimachinery/Pkg/Api/Resource/Quantity/Object/index.html#type-t">Kubernetes.Definitions.Apimachinery.Pkg.Api.Resource.Quantity.Object.t</a>);</code></dt><dd><p>A description of the persistent volume's resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity</p></dd></dl><dl><dt class="spec value" id="val-cephfs"><a href="#val-cephfs" class="anchor"></a><code><span class="keyword">let</span> cephfs: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Ceph_fs_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Ceph_fs_persistent_volume_source.t</a>);</code></dt><dd><p>Ceph_fs represents a Ceph Fs mount on the host that shares a pod's lifetime</p></dd></dl><dl><dt class="spec value" id="val-cinder"><a href="#val-cinder" class="anchor"></a><code><span class="keyword">let</span> cinder: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Cinder_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Cinder_volume_source.t</a>);</code></dt><dd><p>Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md</p></dd></dl><dl><dt class="spec value" id="val-claim_ref"><a href="#val-claim_ref" class="anchor"></a><code><span class="keyword">let</span> claim_ref: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Object_reference/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Object_reference.t</a>);</code></dt><dd><p>Claim_ref is part of a bi_directional binding between Persistent_volume and Persistent_volume_claim. Expected to be non_nil when bound. claim.volume_name is the authoritative bind between Pv and Pvc. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding</p></dd></dl><dl><dt class="spec value" id="val-csi"><a href="#val-csi" class="anchor"></a><code><span class="keyword">let</span> csi: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Csi_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Csi_persistent_volume_source.t</a>);</code></dt><dd><p>Csi represents storage that handled by an external Csi driver (beta feature).</p></dd></dl><dl><dt class="spec value" id="val-fc"><a href="#val-fc" class="anchor"></a><code><span class="keyword">let</span> fc: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Fc_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Fc_volume_source.t</a>);</code></dt><dd><p>Fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.</p></dd></dl><dl><dt class="spec value" id="val-flex_volume"><a href="#val-flex_volume" class="anchor"></a><code><span class="keyword">let</span> flex_volume: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Flex_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Flex_persistent_volume_source.t</a>);</code></dt><dd><p>Flex_volume represents a generic volume resource that is provisioned/attached using an exec based plugin.</p></dd></dl><dl><dt class="spec value" id="val-flocker"><a href="#val-flocker" class="anchor"></a><code><span class="keyword">let</span> flocker: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Flocker_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Flocker_volume_source.t</a>);</code></dt><dd><p>Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running</p></dd></dl><dl><dt class="spec value" id="val-gce_persistent_disk"><a href="#val-gce_persistent_disk" class="anchor"></a><code><span class="keyword">let</span> gce_persistent_disk: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Gce_persistent_disk_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Gce_persistent_disk_volume_source.t</a>);</code></dt><dd><p>Gce_persistent_disk represents a Gce Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk</p></dd></dl><dl><dt class="spec value" id="val-glusterfs"><a href="#val-glusterfs" class="anchor"></a><code><span class="keyword">let</span> glusterfs: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Glusterfs_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Glusterfs_volume_source.t</a>);</code></dt><dd><p>Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md</p></dd></dl><dl><dt class="spec value" id="val-host_path"><a href="#val-host_path" class="anchor"></a><code><span class="keyword">let</span> host_path: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Host_path_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Host_path_volume_source.t</a>);</code></dt><dd><p>Host_path represents a directory on the host. Provisioned by a developer or tester. This is useful for single_node development and testing only! On_host storage is not supported in any way and Will Not Work in a multi_node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath</p></dd></dl><dl><dt class="spec value" id="val-iscsi"><a href="#val-iscsi" class="anchor"></a><code><span class="keyword">let</span> iscsi: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Iscsi_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Iscsi_persistent_volume_source.t</a>);</code></dt><dd><p>Iscsi represents an Iscsi Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.</p></dd></dl><dl><dt class="spec value" id="val-local"><a href="#val-local" class="anchor"></a><code><span class="keyword">let</span> local: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Local_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Local_volume_source.t</a>);</code></dt><dd><p>Local represents directly_attached storage with node affinity</p></dd></dl><dl><dt class="spec value" id="val-mount_options"><a href="#val-mount_options" class="anchor"></a><code><span class="keyword">let</span> mount_options: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(list(string));</code></dt><dd><p>A list of mount options, e.g. [&quot;ro&quot;, &quot;soft&quot;]. Not validated - mount will simply fail if one is invalid. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options</p></dd></dl><dl><dt class="spec value" id="val-nfs"><a href="#val-nfs" class="anchor"></a><code><span class="keyword">let</span> nfs: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Nfs_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Nfs_volume_source.t</a>);</code></dt><dd><p>Nfs represents an Nfs mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs</p></dd></dl><dl><dt class="spec value" id="val-node_affinity"><a href="#val-node_affinity" class="anchor"></a><code><span class="keyword">let</span> node_affinity: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Volume_node_affinity/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Volume_node_affinity.t</a>);</code></dt><dd><p>Node_affinity defines constraints that limit what nodes this volume can be accessed from. This field influences the scheduling of pods that use this volume.</p></dd></dl><dl><dt class="spec value" id="val-persistent_volume_reclaim_policy"><a href="#val-persistent_volume_reclaim_policy" class="anchor"></a><code><span class="keyword">let</span> persistent_volume_reclaim_policy: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(string);</code></dt><dd><p>What happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created Persistent_volumes), Delete (default for dynamically provisioned Persistent_volumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this Persistent_volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming</p></dd></dl><dl><dt class="spec value" id="val-photon_persistent_disk"><a href="#val-photon_persistent_disk" class="anchor"></a><code><span class="keyword">let</span> photon_persistent_disk: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Photon_persistent_disk_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Photon_persistent_disk_volume_source.t</a>);</code></dt><dd><p>Photon_persistent_disk represents a Photon_controller persistent disk attached and mounted on kubelets host machine</p></dd></dl><dl><dt class="spec value" id="val-portworx_volume"><a href="#val-portworx_volume" class="anchor"></a><code><span class="keyword">let</span> portworx_volume: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Portworx_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Portworx_volume_source.t</a>);</code></dt><dd><p>Portworx_volume represents a portworx volume attached and mounted on kubelets host machine</p></dd></dl><dl><dt class="spec value" id="val-quobyte"><a href="#val-quobyte" class="anchor"></a><code><span class="keyword">let</span> quobyte: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Quobyte_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Quobyte_volume_source.t</a>);</code></dt><dd><p>Quobyte represents a Quobyte mount on the host that shares a pod's lifetime</p></dd></dl><dl><dt class="spec value" id="val-rbd"><a href="#val-rbd" class="anchor"></a><code><span class="keyword">let</span> rbd: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Rbd_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Rbd_persistent_volume_source.t</a>);</code></dt><dd><p>Rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md</p></dd></dl><dl><dt class="spec value" id="val-scale_io"><a href="#val-scale_io" class="anchor"></a><code><span class="keyword">let</span> scale_io: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Scale_io_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Scale_io_persistent_volume_source.t</a>);</code></dt><dd><p>Scale_io represents a Scale_io persistent volume attached and mounted on Kubernetes nodes.</p></dd></dl><dl><dt class="spec value" id="val-storage_class_name"><a href="#val-storage_class_name" class="anchor"></a><code><span class="keyword">let</span> storage_class_name: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(string);</code></dt><dd><p>Name of Storage_class to which this persistent volume belongs. Empty value means that this volume does not belong to any Storage_class.</p></dd></dl><dl><dt class="spec value" id="val-storageos"><a href="#val-storageos" class="anchor"></a><code><span class="keyword">let</span> storageos: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Storage_os_persistent_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Storage_os_persistent_volume_source.t</a>);</code></dt><dd><p>Storage_os represents a Storage_os volume that is attached to the kubelet's host machine and mounted into the pod More info: https://releases.k8s.io/HEAD/examples/volumes/storageos/README.md</p></dd></dl><dl><dt class="spec value" id="val-volume_mode"><a href="#val-volume_mode" class="anchor"></a><code><span class="keyword">let</span> volume_mode: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(string);</code></dt><dd><p>volume_mode defines if a volume is intended to be used with a formatted filesystem or to remain in raw block state. Value of Filesystem is implied when not included in spec. This is an alpha feature and may change in the future.</p></dd></dl><dl><dt class="spec value" id="val-vsphere_volume"><a href="#val-vsphere_volume" class="anchor"></a><code><span class="keyword">let</span> vsphere_volume: <a href="index.html#type-t">t</a> <span>=&gt;</span> option(<a href="../Vsphere_virtual_disk_volume_source/index.html#type-t">Kubernetes.Definitions.Api.Core.V1.Vsphere_virtual_disk_volume_source.t</a>);</code></dt><dd><p>Vsphere_volume represents a v_sphere volume attached and mounted on kubelets host machine</p></dd></dl><div class="spec module" id="module-Object"><a href="#module-Object" class="anchor"></a><code><span class="keyword">module</span> <a href="Object/index.html">Object</a>: <a href="../../../../../../Object/index.html#module-type-S">Object.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../../../../Object/module-type-S/index.html#type-value">value</a> := <a href="index.html#type-t">t</a>;</code></div></div></body></html>